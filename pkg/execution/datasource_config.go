// Code generated by graphql-go-tools gen, DO NOT EDIT.
package execution

import ast "github.com/jensneuse/graphql-go-tools/pkg/ast"

type GraphQLDataSourceConfig struct {
	Host   string
	Url    string
	Method HTTP_METHOD
	Params *[]*Parameter
}

func (g *GraphQLDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "host":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			g.Host = val
		case "url":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			g.Url = val
		case "method":
			var val HTTP_METHOD
			val.Unmarshal(doc, doc.ArgumentValue(ii).Ref)
			g.Method = val
		case "params":
			list := make([]*Parameter, 0, len(doc.ListValues[doc.ArgumentValue(ii).Ref].Refs))
			for _, ii := range doc.ListValues[doc.ArgumentValue(ii).Ref].Refs {
				var val Parameter
				val.Unmarshal(doc, doc.Value(ii).Ref)
				list = append(list, &val)
			}
			g.Params = &list
		}
	}
}

type HttpJsonDataSourceConfig struct {
	Host                       string
	Url                        string
	Method                     HTTP_METHOD
	Params                     *[]*Parameter
	Body                       *string
	Headers                    *[]*Header
	DefaultTypeName            *string
	StatusCodeTypeNameMappings *[]*StatusCodeTypeNameMapping
}

func (h *HttpJsonDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "host":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.Host = val
		case "url":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.Url = val
		case "method":
			var val HTTP_METHOD
			val.Unmarshal(doc, doc.ArgumentValue(ii).Ref)
			h.Method = val
		case "params":
			list := make([]*Parameter, 0, len(doc.ListValues[doc.ArgumentValue(ii).Ref].Refs))
			for _, ii := range doc.ListValues[doc.ArgumentValue(ii).Ref].Refs {
				var val Parameter
				val.Unmarshal(doc, doc.Value(ii).Ref)
				list = append(list, &val)
			}
			h.Params = &list
		case "body":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.Body = &val
		case "headers":
			list := make([]*Header, 0, len(doc.ListValues[doc.ArgumentValue(ii).Ref].Refs))
			for _, ii := range doc.ListValues[doc.ArgumentValue(ii).Ref].Refs {
				var val Header
				val.Unmarshal(doc, doc.Value(ii).Ref)
				list = append(list, &val)
			}
			h.Headers = &list
		case "defaultTypeName":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.DefaultTypeName = &val
		case "statusCodeTypeNameMappings":
			list := make([]*StatusCodeTypeNameMapping, 0, len(doc.ListValues[doc.ArgumentValue(ii).Ref].Refs))
			for _, ii := range doc.ListValues[doc.ArgumentValue(ii).Ref].Refs {
				var val StatusCodeTypeNameMapping
				val.Unmarshal(doc, doc.Value(ii).Ref)
				list = append(list, &val)
			}
			h.StatusCodeTypeNameMappings = &list
		}
	}
}

type HttpPollingStreamDataSourceConfig struct {
	Host         string
	Url          string
	Method       HTTP_METHOD
	DelaySeconds int64
	Params       *[]*Parameter
}

func (h *HttpPollingStreamDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	h.DelaySeconds = doc.DirectiveDefinitionArgumentDefaultValueInt64("HttpPollingStreamDataSource", "delaySeconds")
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "host":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.Host = val
		case "url":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			h.Url = val
		case "method":
			var val HTTP_METHOD
			val.Unmarshal(doc, doc.ArgumentValue(ii).Ref)
			h.Method = val
		case "delaySeconds":
			val := doc.IntValueAsInt(doc.ArgumentValue(ii).Ref)
			h.DelaySeconds = val
		case "params":
			list := make([]*Parameter, 0, len(doc.ListValues[doc.ArgumentValue(ii).Ref].Refs))
			for _, ii := range doc.ListValues[doc.ArgumentValue(ii).Ref].Refs {
				var val Parameter
				val.Unmarshal(doc, doc.Value(ii).Ref)
				list = append(list, &val)
			}
			h.Params = &list
		}
	}
}

type MappingConfig struct {
	Mode         MAPPING_MODE
	PathSelector *string
}

func (m *MappingConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "mode":
			var val MAPPING_MODE
			val.Unmarshal(doc, doc.ArgumentValue(ii).Ref)
			m.Mode = val
		case "pathSelector":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			m.PathSelector = &val
		}
	}
}

type MQTTDataSourceConfig struct {
	BrokerAddr string
	ClientID   string
	Topic      string
}

func (m *MQTTDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "brokerAddr":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			m.BrokerAddr = val
		case "clientID":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			m.ClientID = val
		case "topic":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			m.Topic = val
		}
	}
}

type NatsDataSourceConfig struct {
	Addr  string
	Topic string
}

func (n *NatsDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "addr":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			n.Addr = val
		case "topic":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			n.Topic = val
		}
	}
}

type PipelineDataSourceConfig struct {
	ConfigFilePath *string
	ConfigString   *string
	InputJSON      string
}

func (p *PipelineDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "configFilePath":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			p.ConfigFilePath = &val
		case "configString":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			p.ConfigString = &val
		case "inputJSON":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			p.InputJSON = val
		}
	}
}

type StaticDataSourceConfig struct {
	Data *string
}

func (s *StaticDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "data":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			s.Data = &val
		}
	}
}

type TransformationConfig struct {
	Mode                 TRANSFORMATION_MODE
	PipelineConfigFile   *string
	PipelineConfigString *string
}

func (t *TransformationConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "mode":
			var val TRANSFORMATION_MODE
			val.Unmarshal(doc, doc.ArgumentValue(ii).Ref)
			t.Mode = val
		case "pipelineConfigFile":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			t.PipelineConfigFile = &val
		case "pipelineConfigString":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			t.PipelineConfigString = &val
		}
	}
}

type WasmDataSourceConfig struct {
	Input    string
	WasmFile string
}

func (w *WasmDataSourceConfig) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.Directives[ref].Arguments.Refs {
		name := doc.ArgumentNameString(ii)
		switch name {
		case "input":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			w.Input = val
		case "wasmFile":
			val := doc.StringValueContentString(doc.ArgumentValue(ii).Ref)
			w.WasmFile = val
		}
	}
}

type HTTP_METHOD int

func (h *HTTP_METHOD) Unmarshal(doc *ast.Document, ref int) {
	switch doc.EnumValueNameString(ref) {
	case "GET":
		*h = HTTP_METHOD_GET
	case "POST":
		*h = HTTP_METHOD_POST
	case "UPDATE":
		*h = HTTP_METHOD_UPDATE
	case "DELETE":
		*h = HTTP_METHOD_DELETE
	}
}

const (
	UNDEFINED_HTTP_METHOD HTTP_METHOD = iota
	HTTP_METHOD_GET
	HTTP_METHOD_POST
	HTTP_METHOD_UPDATE
	HTTP_METHOD_DELETE
)

type MAPPING_MODE int

func (m *MAPPING_MODE) Unmarshal(doc *ast.Document, ref int) {
	switch doc.EnumValueNameString(ref) {
	case "NONE":
		*m = MAPPING_MODE_NONE
	case "PATH_SELECTOR":
		*m = MAPPING_MODE_PATH_SELECTOR
	}
}

const (
	UNDEFINED_MAPPING_MODE MAPPING_MODE = iota
	MAPPING_MODE_NONE
	MAPPING_MODE_PATH_SELECTOR
)

type PARAMETER_SOURCE int

func (p *PARAMETER_SOURCE) Unmarshal(doc *ast.Document, ref int) {
	switch doc.EnumValueNameString(ref) {
	case "CONTEXT_VARIABLE":
		*p = PARAMETER_SOURCE_CONTEXT_VARIABLE
	case "OBJECT_VARIABLE_ARGUMENT":
		*p = PARAMETER_SOURCE_OBJECT_VARIABLE_ARGUMENT
	case "FIELD_ARGUMENTS":
		*p = PARAMETER_SOURCE_FIELD_ARGUMENTS
	}
}

const (
	UNDEFINED_PARAMETER_SOURCE PARAMETER_SOURCE = iota
	PARAMETER_SOURCE_CONTEXT_VARIABLE
	PARAMETER_SOURCE_OBJECT_VARIABLE_ARGUMENT
	PARAMETER_SOURCE_FIELD_ARGUMENTS
)

type TRANSFORMATION_MODE int

func (t *TRANSFORMATION_MODE) Unmarshal(doc *ast.Document, ref int) {
	switch doc.EnumValueNameString(ref) {
	case "PIPELINE":
		*t = TRANSFORMATION_MODE_PIPELINE
	}
}

const (
	UNDEFINED_TRANSFORMATION_MODE TRANSFORMATION_MODE = iota
	TRANSFORMATION_MODE_PIPELINE
)

type Header struct {
	Key   string
	Value string
}

func (h *Header) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.ObjectValues[ref].Refs {
		name := string(doc.ObjectFieldNameBytes(ii))
		switch name {
		case "key":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			h.Key = val
		case "value":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			h.Value = val
		}
	}
}

type Parameter struct {
	Name         string
	SourceKind   PARAMETER_SOURCE
	SourceName   string
	VariableType string
}

func (p *Parameter) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.ObjectValues[ref].Refs {
		name := string(doc.ObjectFieldNameBytes(ii))
		switch name {
		case "name":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			p.Name = val
		case "sourceKind":
			var val PARAMETER_SOURCE
			val.Unmarshal(doc, doc.ObjectFieldValue(ii).Ref)
			p.SourceKind = val
		case "sourceName":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			p.SourceName = val
		case "variableType":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			p.VariableType = val
		}
	}
}

type StatusCodeTypeNameMapping struct {
	StatusCode int64
	TypeName   string
}

func (s *StatusCodeTypeNameMapping) Unmarshal(doc *ast.Document, ref int) {
	for _, ii := range doc.ObjectValues[ref].Refs {
		name := string(doc.ObjectFieldNameBytes(ii))
		switch name {
		case "statusCode":
			val := doc.IntValueAsInt(doc.ObjectFieldValue(ii).Ref)
			s.StatusCode = val
		case "typeName":
			val := doc.StringValueContentString(doc.ObjectFieldValue(ii).Ref)
			s.TypeName = val
		}
	}
}

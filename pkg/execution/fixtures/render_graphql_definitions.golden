directive @GraphQLDataSource
    """
    the host of the origin
    """
    host: String! 
    """
    the url of the origin
    """
    url: String! 
    """
    the HTTP method the client should use for the request, defaults to GET
    """
    method: HTTP_METHOD = POST 
    """
    parameters
    """
    params: [Parameter]
 on FIELD_DEFINITION

directive @HttpJsonDataSource
    """
    the host of the origin
    """
    host: String! 
    """
    the url of the origin
    """
    url: String! 
    """
    the HTTP method the client should use for the request, defaults to GET
    """
    method: HTTP_METHOD = GET 
    """
    parameters
    """
    params: [Parameter] 
    """
    body is the optional definition of the http body to be sent to the upstream
    golang templating syntax might be used to create the body
    """
    body: String 
    """
    headers are the key value pairs to be set on the upstream request
    """
    headers: [Header]
 on FIELD_DEFINITION

"""
HttpPollingStreamDataSource
"""
directive @HttpPollingStreamDataSource
    """
    host is the host name of the data source, e.g. example.com
    """
    host: String! 
    """
    url is the URL from which the data source should poll data from
    you could use golang templating syntax, e.g.:
    '/users/{{ .Id }}' + parameter named id with value 1 (see below) will render to URL '/users/1'
    """
    url: String! 
    "method is the HTTP method the data source should use to fetch data from the upstream"
    method: HTTP_METHOD = GET 
    "the delay in seconds between each polling"
    delaySeconds: Int = 5 
    """
    params are the parameters that should get passed to the data source
    you could use this function to pass variables from field variables, the context or parent object to the data source
    thse could be used to 'render' the url dynamically
    """
    params: [Parameter]
 on FIELD_DEFINITION

"""
mapping is the directive to define mappings from response objects to GraphQL fields
"""
directive @mapping
    """
    mode defines the operating mode of the mapping
    """
    mode: MAPPING_MODE! = PATH_SELECTOR 
    """
    pathSelector is the optional selector String to customize the mappings
    see https://github.com/tidwall/gjson for more information on what syntax is possible
    """
    pathSelector: String
 on FIELD_DEFINITION

"""
NatsDataSource
"""
directive @NatsDataSource
    addr: String! 
    topic: String!
 on FIELD_DEFINITION

directive @StaticDataSource
    data: String
 on FIELD_DEFINITION

enum HTTP_METHOD {
    GET
    POST
    UPDATE
    DELETE
}

"""
MAPPING_MODE is the enum to define the different mapper modes
"""
enum MAPPING_MODE {
    """
    NONE is the mode to skip mappings at all, therefore the parent object will directly get passed to the child
    """
    NONE
    """
    PATH_SELECTOR is the mode which applies a path selector string on the parent object before passing it to the child
    see https://github.com/tidwall/gjson for more information on what syntax is possible
    """
    PATH_SELECTOR
}

"PARAMETER_SOURCE defines the source of a dyanmic parameter"
enum PARAMETER_SOURCE {
    "parameter from the context object which could be pupulated by the http wrapper"
    CONTEXT_VARIABLE
    """
    parameter from the parent object
    example:
    consider the following query:
    {
    user(id: 1) {
    userID
    friends
    }
    }
    Using the PARAMETER_SOURCE 'OBJECT_VARIABLE_ARGUMENT' with sourceName 'userID' returns the userID for user with id 1 at runtime.
    This way you can dynamically build a query to the friends ressource using the userID at runtime and inject it into the second query.
    """
    OBJECT_VARIABLE_ARGUMENT
    """
    parameter from the field arguments
    example:
    consider the following query:
    {
    user(id: 1) {
    friends
    }
    }
    Using the PARAMETER_SOURCE 'FIELD_ARGUMENTS' with sourceName 'id' returns 1 at runtime.
    This way you can render the ressource url for /user/:id to /user/1 at runtime dynamically.
    """
    FIELD_ARGUMENTS
}

input Header {
    key: String! 
    value: String!
}

"""
Parameter is useful to map variables from various sources into the data source executor.
"""
input Parameter {
    """
    this is the name by which the execution engine will access the variable
    """
    name: String! 
    """
    the kind of the parameter source
    currently sources: the context, the enclosing object (at execution time), field variables
    """
    sourceKind: PARAMETER_SOURCE! 
    """
    name of the parameter on the source
    """
    sourceName: String! 
    """
    type name of the variable, used to generate a valid GraphQL query for the upstream
    """
    variableType: String!
}
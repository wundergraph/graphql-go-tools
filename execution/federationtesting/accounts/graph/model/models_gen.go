// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type Ab interface {
	IsAb()
}

type AbstractListItem interface {
	IsAbstractListItem()
	GetObj() OtherInterface
}

type Cd interface {
	IsCd()
}

type CDer interface {
	IsCDer()
	GetName() *CDerObj
}

type History interface {
	IsHistory()
}

type Identifiable interface {
	IsIdentifiable()
	GetID() string
}

type Info interface {
	IsInfo()
	GetQuantity() int
}

type MeUnion interface {
	IsMeUnion()
}

type Name interface {
	IsName()
	GetName() string
}

type Namer interface {
	IsNamer()
	GetName() string
}

type OtherInterface interface {
	IsOtherInterface()
	GetName() string
	GetNames() []string
}

type SomeInterface interface {
	IsSomeInterface()
	GetSomeObject() *SomeObject
}

type SomeNestedInterface interface {
	IsSomeNestedInterface()
	GetOtherInterfaces() []SomeInterface
}

type Store interface {
	IsStore()
	GetLocation() string
}

type Title interface {
	IsTitle()
	GetTitle() string
}

type Wallet interface {
	IsWallet()
	GetCurrency() string
	GetAmount() float64
}

type A struct {
	Name string `json:"name"`
}

func (A) IsAb() {}

func (A) IsNamer()             {}
func (this A) GetName() string { return this.Name }

type Admin struct {
	ID       string `json:"id"`
	Username string `json:"username"`
	Role     string `json:"role"`
}

func (Admin) IsIdentifiable()    {}
func (this Admin) GetID() string { return this.ID }

func (Admin) IsMeUnion() {}

func (Admin) IsEntity() {}

type B struct {
	Name string `json:"name"`
}

func (B) IsAb() {}

func (B) IsNamer()             {}
func (this B) GetName() string { return this.Name }

type C struct {
	Name *CDerObj `json:"name,omitempty"`
}

func (C) IsCd() {}

func (C) IsCDer()                {}
func (this C) GetName() *CDerObj { return this.Name }

type CDerObj struct {
	First  string `json:"first"`
	Middle string `json:"middle"`
	Last   string `json:"last"`
}

type Cat struct {
	Name string `json:"name"`
}

type ConcreteListItem1 struct {
	Obj OtherInterface `json:"obj"`
}

func (ConcreteListItem1) IsAbstractListItem()         {}
func (this ConcreteListItem1) GetObj() OtherInterface { return this.Obj }

type ConcreteListItem2 struct {
	Obj OtherInterface `json:"obj"`
}

func (ConcreteListItem2) IsAbstractListItem()         {}
func (this ConcreteListItem2) GetObj() OtherInterface { return this.Obj }

type D struct {
	Name *CDerObj `json:"name,omitempty"`
}

func (D) IsCd() {}

func (D) IsCDer()                {}
func (this D) GetName() *CDerObj { return this.Name }

type Product struct {
	Upc string `json:"upc"`
}

func (Product) IsEntity() {}

type Purchase struct {
	Product  *Product `json:"product"`
	Wallet   Wallet   `json:"wallet,omitempty"`
	Quantity int      `json:"quantity"`
}

func (Purchase) IsHistory() {}

func (Purchase) IsInfo()               {}
func (this Purchase) GetQuantity() int { return this.Quantity }

type Query struct {
}

type Sale struct {
	Product  *Product `json:"product"`
	Rating   int      `json:"rating"`
	Location string   `json:"location"`
}

func (Sale) IsHistory() {}

func (Sale) IsStore()                 {}
func (this Sale) GetLocation() string { return this.Location }

type SomeNestedType1 struct {
	OtherInterfaces []SomeInterface `json:"otherInterfaces,omitempty"`
}

func (SomeNestedType1) IsSomeNestedInterface() {}
func (this SomeNestedType1) GetOtherInterfaces() []SomeInterface {
	if this.OtherInterfaces == nil {
		return nil
	}
	interfaceSlice := make([]SomeInterface, 0, len(this.OtherInterfaces))
	for _, concrete := range this.OtherInterfaces {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SomeNestedType2 struct {
	OtherInterfaces []SomeInterface `json:"otherInterfaces,omitempty"`
}

func (SomeNestedType2) IsSomeNestedInterface() {}
func (this SomeNestedType2) GetOtherInterfaces() []SomeInterface {
	if this.OtherInterfaces == nil {
		return nil
	}
	interfaceSlice := make([]SomeInterface, 0, len(this.OtherInterfaces))
	for _, concrete := range this.OtherInterfaces {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SomeObject struct {
	A string `json:"a"`
	B string `json:"b"`
	C string `json:"c"`
}

type SomeType1 struct {
	Name       string      `json:"name"`
	Age        int         `json:"age"`
	Names      []string    `json:"names"`
	SomeObject *SomeObject `json:"someObject"`
}

func (SomeType1) IsOtherInterface()    {}
func (this SomeType1) GetName() string { return this.Name }
func (this SomeType1) GetNames() []string {
	if this.Names == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Names))
	for _, concrete := range this.Names {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (SomeType1) IsSomeInterface()                {}
func (this SomeType1) GetSomeObject() *SomeObject { return this.SomeObject }

type SomeType2 struct {
	Name       string      `json:"name"`
	Height     float64     `json:"height"`
	Names      []string    `json:"names"`
	SomeObject *SomeObject `json:"someObject"`
}

func (SomeType2) IsOtherInterface()    {}
func (this SomeType2) GetName() string { return this.Name }
func (this SomeType2) GetNames() []string {
	if this.Names == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Names))
	for _, concrete := range this.Names {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (SomeType2) IsSomeInterface()                {}
func (this SomeType2) GetSomeObject() *SomeObject { return this.SomeObject }

type SomeType3 struct {
	SomeObject *SomeObject `json:"someObject"`
}

func (SomeType3) IsSomeInterface()                {}
func (this SomeType3) GetSomeObject() *SomeObject { return this.SomeObject }

type TitleName struct {
	A     string `json:"a"`
	B     string `json:"b"`
	C     string `json:"c"`
	Title string `json:"title"`
	Name  string `json:"name"`
}

func (TitleName) IsTitle()              {}
func (this TitleName) GetTitle() string { return this.Title }

func (TitleName) IsName()              {}
func (this TitleName) GetName() string { return this.Name }

type User struct {
	ID           string    `json:"id"`
	Username     string    `json:"username"`
	Nickname     string    `json:"nickname"`
	History      []History `json:"history"`
	RealName     string    `json:"realName"`
	RelatedUsers []*User   `json:"relatedUsers"`
}

func (User) IsIdentifiable()    {}
func (this User) GetID() string { return this.ID }

func (User) IsMeUnion() {}

func (User) IsEntity() {}

type WalletType1 struct {
	Currency      string  `json:"currency"`
	Amount        float64 `json:"amount"`
	SpecialField1 string  `json:"specialField1"`
}

func (WalletType1) IsWallet()                {}
func (this WalletType1) GetCurrency() string { return this.Currency }
func (this WalletType1) GetAmount() float64  { return this.Amount }

type WalletType2 struct {
	Currency      string  `json:"currency"`
	Amount        float64 `json:"amount"`
	SpecialField2 string  `json:"specialField2"`
}

func (WalletType2) IsWallet()                {}
func (this WalletType2) GetCurrency() string { return this.Currency }
func (this WalletType2) GetAmount() float64  { return this.Amount }

type Which string

const (
	WhichA Which = "A"
	WhichB Which = "B"
)

var AllWhich = []Which{
	WhichA,
	WhichB,
}

func (e Which) IsValid() bool {
	switch e {
	case WhichA, WhichB:
		return true
	}
	return false
}

func (e Which) String() string {
	return string(e)
}

func (e *Which) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Which(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Which", str)
	}
	return nil
}

func (e Which) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Which) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Which) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

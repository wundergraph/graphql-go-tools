package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/wundergraph/graphql-go-tools/execution/federationtesting/accounts/graph/generated"
	"github.com/wundergraph/graphql-go-tools/execution/federationtesting/accounts/graph/model"
)

// FindAdminByID is the resolver for the findAdminByID field.
func (r *entityResolver) FindAdminByID(ctx context.Context, id string) (*model.Admin, error) {
	name := "Admin " + id
	if id == "admin-1" {
		name = "SuperAdmin"
	}
	return &model.Admin{
		ID:       id,
		Username: name,
		Role:     "administrator",
	}, nil
}

// FindUserByID is the resolver for the findUserByID field.
func (r *entityResolver) FindUserByID(ctx context.Context, id string) (*model.User, error) {
	name := "User " + id
	if id == "1234" {
		name = "Me"
	}

	// RelatedUsers creates a dependency chain for L1 cache testing:
	// - User 1234's relatedUsers includes User 1234 (self) and User 7777
	// - User 7777's relatedUsers includes User 7777 (self) and User 1234
	// When querying relatedUsers.relatedUsers, the nested users are the same
	// as the outer users, which should hit L1 cache.
	var relatedUsers []*model.User
	switch id {
	case "1234":
		// User 1234 is related to User 7777 and themselves
		relatedUsers = []*model.User{
			{ID: "1234"}, // Self-reference for L1 hit
			{ID: "7777"},
		}
	case "7777":
		// User 7777 is related to User 1234 and themselves
		relatedUsers = []*model.User{
			{ID: "7777"}, // Self-reference for L1 hit
			{ID: "1234"},
		}
	default:
		// Other users relate to User 1234
		relatedUsers = []*model.User{
			{ID: id}, // Self-reference
			{ID: "1234"},
		}
	}

	return &model.User{
		ID:           id,
		Username:     name,
		History:      histories,
		RelatedUsers: relatedUsers,
	}, nil
}

// Entity returns generated.EntityResolver implementation.
func (r *Resolver) Entity() generated.EntityResolver { return &entityResolver{r} }

type entityResolver struct{ *Resolver }
